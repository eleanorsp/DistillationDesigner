//
//  McCabeGraphView.m
//  DistillationDesigner
//
//  Created by Eleanor Spenceley on 02/03/2008.
//  Copyright 2008 Crumpets Farm. All rights reserved.
//

#import "McCabeGraphView.h"


@implementation McCabeGraphView

- (id) initWithFrame:(NSRect)frameRect
{
    self = [super initWithFrame:frameRect];
    
    return self;
}

// -----------------------------------
// Draw the View Content
// -----------------------------------

- (void)drawRect:(NSRect)rect
{
    // erase the background by drawing white
    [ super drawRect:rect ];
	
    // draw the draggable item
	CGContextRef gc = [[NSGraphicsContext currentContext] graphicsPort];	
	[ (McCabeThiele*) itsGraph drawRectifyingLine: gc inMode: [ ( (McCabeThiele*) itsGraph) getMode ] ];
	
	return;
}


- (void) startMinRefluxReview
{
	minRefluxStarted = YES;
}

// -----------------------------------
// Handle Mouse Events 
// -----------------------------------

-(void)mouseDown:(NSEvent *)event
{
    NSPoint clickLocation;
    BOOL itemHit=NO;
 
	if ( minRefluxStarted == YES )
	{
		// convert the click location into the view coords
		clickLocation = [self convertPoint:[event locationInWindow]
								  fromView: [ [ event window] contentView ] ];
		
		// did the click occur in the item?
		itemHit = [self isPointInMinRefluxGraphLimits:clickLocation ];
		
		// Yes it did, note that we're starting to drag
		if (itemHit) 
		{
			// flag the instance variable that indicates 
			// a drag was actually started
			dragging=YES;
			
			// store the starting click location;
			lastDragLocation=clickLocation;
			
			// set the cursor to the closed hand cursor
			// for the duration of the drag
			[[NSCursor closedHandCursor] push];
		}
	}
	
	return;
}

-(void)mouseDragged:(NSEvent *)event
{
	if ( minRefluxStarted == YES )
	{
		if (dragging) 
		{
			NSPoint newDragLocation=[self convertPoint:[event locationInWindow]
											  fromView: [ [ event window] contentView ] ];
		//	newDragLocation.x = newDragLocation.x - itsGraph.xMinPosition;
		//	newDragLocation.y = newDragLocation.y - itsGraph.yMinPosition;
			
			
			// offset the pill by the change in mouse movement
			// in the event
			[self offsetLineByX:newDragLocation.x
							   andY:newDragLocation.y];
			
			// save the new drag location for the next drag event
			lastDragLocation=newDragLocation;
			
			// support automatic scrolling during a drag
			// by calling NSView's autoscroll: method
			[self autoscroll:event];
		}
	}
	else
		[ super mouseDragged: event ];
	
	return;
}

-(void)mouseUp:(NSEvent *)event
{
	if ( minRefluxStarted == YES )
	{
		dragging=NO;
    
		// finished dragging, restore the cursor
		[NSCursor pop];
    
		// the item has moved, we need to reset our cursor
		// rectangle
		[[self window] invalidateCursorRectsForView:self];

		// Stop the ability to drag.
		minRefluxStarted = NO;
	}
	
	return;
}


// -----------------------------------
// Hit test the item
// -----------------------------------

- (BOOL) isPointInMinRefluxGraphLimits:(NSPoint)testPoint
{
    BOOL itemHit=NO;
    
    // test first if we're in the rough bounds
    itemHit = NSPointInRect(testPoint,[self calculatedItemBounds]);
    
    // yes, lets further refine the testing
    if (itemHit) {
		
    }
	
    return itemHit;
}

- (NSRect)calculatedItemBounds
{
    NSRect calculatedRect;
    
    // calculate the bounds of the draggable item
    // relative to the location
    calculatedRect.origin=NSMakePoint( itsGraph.xMinPosition, itsGraph.yMinPosition );
    
	// NSPoint topCompPoint = [ itsGraph normalisePoint: ( (McCabeThiele*) itsGraph).rectifyingLine.startPoint ];
	
    // the example assumes that the width and height
    // are fixed values
    calculatedRect.size.width =  itsGraph.xMaxPosition - itsGraph.xMinPosition;
    calculatedRect.size.height= itsGraph.yMaxPosition - itsGraph.yMinPosition;
    
    return calculatedRect;
}



// -----------------------------------
// Modify the item location 
// -----------------------------------

- (void)offsetLineByX:(CGFloat)x andY:(CGFloat)y
{
    // tell the display to redraw the old rect
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
	
    // since the offset can be generated by both mouse moves
    // and moveUp:, moveDown:, etc.. actions, we'll invert
    // the deltaY amount based on if the view is flipped or 
    // not.
   // int invertDeltaY = [self isFlipped] ? -1: 1;
    
	CGFloat xMinPosition = itsGraph.xMinPosition;
	CGFloat yMinPosition = itsGraph.yMinPosition;
	// CGFloat yMaxPosition = itsGraph.yMaxPosition;
	
	CGFloat yInGraph = y; // - yMinPosition;
	CGFloat xInGraph = x; // - xMinPosition;

	NSPoint topPoint = [ itsGraph normalisePoint:  ( (McCabeThiele*) itsGraph).minRefluxLine.startPoint ];

	// 	y = mx + c
	//  c = 0;
	CGFloat m = ( topPoint.y - yInGraph )/(topPoint.x - xInGraph);
	// Now calc y where x = 0;
	CGFloat yatxzero = ( topPoint.x - xMinPosition ) * m;
	yatxzero = topPoint.y - yatxzero;
	CGFloat yatxzeroActual = (yatxzero - yMinPosition)/(itsGraph.yMaxPosition - itsGraph.yMinPosition);
	
    [ (McCabeThiele* ) itsGraph setMinRefluxAtYAtXzero: yatxzeroActual ];
	
	// 
	
    // invalidate the new rect location so that it'll
    // be redrawn
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
    
}

@synthesize minRefluxStarted;
//@synthesize zoomFactor;


@end
